# 1.算分算法
## 1.1TF-IDF算法 
TF：词在文档中出现的频率。  检索词出现的次数除以文档的总数
IDF：DF表示词在所有文档中出现的频率，IDF：log(全部文档数/检索词出现过的文档总数)，假设出现过次数很大，比如全部都有那么，IDF就是log(1) = 0 。
TF-IDF：TF乘IDF

## 2.BM25算法
对TF-IDF的一种优化，TF增大的时候不会无限增大，而是趋于稳定

# 2.DisMaxQuery
正常是所有分数相加，可以通过DisMaxQuery来让搜索按照最高分项来返回
```sh
PUT blog/_doc/1
{
    "title":"quick brown rabbits",
    "body":"brown rabbits are commonly seen"
}

PUT blog/_doc/2
{
    "title":"Keeping pets healthy",
    "body":"my quick brown fox eats rabbits on a regular b basis"
}

#正常是tile和body的分数相加
POST blog/_search
{
    "query":{
        "bool":{
            "should":[
                {"match":{"title":"brown fox"}},
                {"match":{"body":"brown fox"}}
            ]
        }
    }
}
#匹配最高分数返回
#也可以用tie_breaker给其他的匹配项的分数一个系数
POST blog/_search
{
    "query":{
        "dis_max":{
            "queries":[
                {"match":{"title":"brown fox"}},
                {"match":{"body":"brown fox"}}
            ],
            "tie_breaker": 0.7
        }
    }
}
```

# 3.MultiMatch 单字符串多字段
一个query去匹配多个字段的值
## 3.1最佳匹配best fields(默认)
评分来自最佳匹配的字段，通常取nickname和career中评分高的作为文档的评分，通过设置tie_breaker也可以给非最高的分取一个权重后加如到总评分。按照最终的分数排序
```sh
GET test/_search
{
  "query": {
    "multi_match": {
      "query": "张",
      "tie_breaker": 0.2, 
      "type": "best_fields", 
      "fields": ["nickname","career"]
    }
  }
}
```
## 3.2多数字段most fields
匹配的字段越多，分数越高。 考虑一种情况，比如某个字段用了english分词器，那么单词的时态会被去掉。匹配时如果输入的单词包含了时态，那么搜出的排序可能不是想要的：
```sh
#假设title用的是english分词器
POST test/_bulk
{"index":{"_id":1}}
{"title:"my dog barks"}
{"index":{"_id":2}}
{"title":"i see a lot of barking dogs on the road"}

#1的分词结果my dog bark
#2的分词结果 i see lot bark dog road 
#查询的结果排序1会靠前，因为barking dogs也被改写成了bark dog。显然1跟匹配
GET test/_search
{
  "query": {
    "multi_match": {
      "query": "barking dogs",
      "type": "best_fields", 
      "fields": ["title"]
    }
  }
}

#针对上述的情况，可以增加一个字段title.std，并且指定为standar分词器，然后most fileds去匹配。
#stantdar不会改写原文。所以2的title.std还可以匹配上barking dogs，2比1能匹配上的字段更多
GET test/_search
{
  "query": {
    "multi_match": {
      "query": "barking dogs",
      "type": "most_fields", 
      "fields": ["title","title.std"]
    }
  }
}

```
## 3.3混合字段cross field
考虑存储地址的场景，地址可能会分开存储，比如省、市、县/区、镇/乡/街道、门牌。

但是搜索的输入可能是市+街道，也有可能省+街道。比如广东省西乡街道、宝安区西乡街道。这种情况要如何搜索呢？

一种方案是使用copy_to，将这些字段复制到另一个字段，还一种方案就是cross field
```sh
GET test/_search
{
  "query": {
    "multi_match": {
      "query": "广东省西乡街道",
      "type": "cross_fields", 
      "operator": "and",
      "fields": ["province","city","street"]
    }
  }
}
```
