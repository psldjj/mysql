# 1.MVCC
mvcc即多版本并发控制，用来控制事务可以看到的数据。实现事务的隔离性

## 1.1回滚日志
回滚日志(undo log)记录了数据被更新时的逆序操作，数据每次被更新就会生成一条日志。通过这条日志就可以将当前版本的数据一直回滚到需要的状态。

## 1.2事务id和row_id
**事务id(transaction id)**：是事务开始时向innodb申请的，按照申请的顺序严格递增。<br>
**row id**：每次事务更新数据时，数据就会生成一个新的版本。并且这个版本的row id会被赋值成事务id<br>

## 1.3具体实现
### 1.3.1 可重复读
按照可重复读的定义，已经提交的事务修改可以看见，没提交的后在事务开始后就都不能看见了。<br>
1、事务启动时生成一个数组，数组包括当前正在执行的事务id<br>
2、查询数据时从数据的当前版本开始回滚，直到回滚到事务可以看见的版本为止<br>
3、事务可以看见的版本判断：<br>
>1、数据的版本（row id，即修改数据的事务id）比数组中最小值还要小的。说明是这个事务开始前就提交了事务，所以能看见<br>
>2、数据的版本比数组中最大值还要大的，说明是这个事务开始后才提交的事务，不能看见<br>
>3、在最小和最大之间的。如果事务在数组中，说明当前事务开始时，事务还没提交，所以不能看见。<br>
>4、在最小和最大值之间。如果没在数组中，说明当前事务开始时那些事务就提交了，所以可以看见。<br>

### 1.3.2 读已提交
判断流程基本和可重复读一致，区别是，可重复读是事务开始时生成这个数组。读已提交是**每次查询都生成这个数组**。所以每次查询时提交了的事务都可以看到。

## 1.4当前读和快照读
**当前读**：读取数据的当前版本，update、select...for update都是当前读，因为要更新数据。必须要在已经提交的事务基础上更新，不然数据就丢了。
**快照读（一致读）**：读的是当前事务可以看到的数据版本。